# Абстрактный тип данных

**Абстрактный тип данных (АТД)** – это тип данных, который предоставляет для работы с элементами этого
типа определённый набор функций или операций. Вся внутренняя структура такого типа спрятана от
использующего его разработчика программного обеспечения, то есть мы абстрагируемся от его внутреннего
устройства при использовании. В C++ АТД реализуется классом, в котором нет открытых членов-данных.

**Цель** – реализовать и протестировать новый класс, представляющий абстрактный тип данных, т.е. такой,
пользователи которого могут обращаться только к публичным операциям, предусмотренными создателем класса,
и не имеют информации о внутреннем его устройстве.

**Средство** – язык С++

**Пользователем** (клиентом) класса считается не "пользователь программы" или "компьютерный пользователь"
вообще, а программист, использующий ваш класс для решения своих задач, пишущий свою программу на его основе.
Иногда также под пользователями класса понимаются другие классы, фрагменты программ, которые пользуются
его услугами.

## Дополнительные требования и условия к Task2

По заданию **требуется** использовать язык C++ (а не C), старайтесь использовать средства языка С++ (ввод-вывод
cin/cout и т.п.; new и delete, а не malloc/free).

В данном задании **не разрешается** использовать контейнеры из STL языка C++. Написание собственных аналогов
стандартных STL контейнеров (например, string и vector) с соответствующим набором функций приветствуется.
Методы (нестатические), которые не изменяют состояние объекта, должны быть объявлены как константные, если
это не противоречит смыслу использования АТД.

Программа должна быть представлена минимум **тремя** файлами:
- <АТД>.h – объявлено все, что необходимо включить в программу, для использования вашего класса АТД,

- <АТД>.cpp – реализации нетривиальных методов класса,
- main.cpp – пользовательский интерфейс для тестирования.

При **тестировании** в поток stderr выводятся результаты теста или ошибки, полученные в ходе теста (для заранее
заданного набора тестов также должен выводиться номер теста). Makefile (или аналог) должен содержать цель clean
для уборки за собой, а также цель test, которая компилирует main.cpp и прогоняет заранее заданный набор тестов и
завершает программу (это можно реализовать с помощью argv). По умолчанию подразумевается цель test.

Для класса, реализующего АТД, необходимо **определить**:

- конструктор по умолчанию,
- конструктор копирования (глубокое копирование, если необходимо),
- операцию присваивания (предварительно уничтожить старое значение + см. требование выше относительно
копирования),
- деструктор (стоит предусмотреть ситуацию повторного вызова деструктора: он не должен пытаться в этом
случае освобождать в динамической памяти объекты повторно – это может привести к ошибке выполнения),
- базовый класс исключения, выбрасываемого всеми операциями класса, возможно с потомками – для более
детальной классификации ошибок, – вложен в основной класс (например, string_list::error).

Правильный вывод ошибок должен содержать, хотя бы приблизительно, номер строки, в которой произошла
ошибка.

## Вариант 6. Граф

Релизовать текстовое представление графа (в виде строки). Например: "( (1, 2, 3, 4), ((1,'a', 2),(2,'abc', 3)) )"
задает граф с вершинами 1, 2, 3 и двумя ребрами: с пометкой "a" из 1 в 2 и с пометкой "abc" из 2 в 3, вершина
4 изолирована. Придумайте вспомогательные классы "вершина", "ребро (дуга)", которые бы незаметно для
пользователя конструировались из строк, превращались в строки, и т.д.

### Вариант 6.1 (****) Ориентированный граф

Обязательные операции:

- [X] добавление (add – одна функция с разным набором аргументов): вершины, ребра, дуги;

- [X] удаление (remove – одна функция с разным набором аргументов): вершины, ребра, дуги;

- [X] вывод списка дуг, исходящих из вершины;

- [ ] операция + (объединение графов, добавление вершины, добавление ребра на те же вершины или вместе с
одной новой вершиной или с двумя новыми вершинами, если их еще нет в графе);

- [ ] операция – (минус) – удаление из графа (вершины, ребра, дуги);

- [ ] операция delete[] – в качестве синонима для удаления вершины;

- [ ] проверка достижимости одной вершины из другой;

- [X] перегрузка операции << – вывод графа, в удобном для чтения виде;

- [X] поиск сильно связных компонент.

### Вариант 6.2 (*****) Ориентированный граф с петлями

Дополнительные функции:

- [ ] поиск всех возможных путей из вершины в вершину (по каждому ребру можно проходить ровно 1 раз) –
придумать класс + текстовое представление пути;

- [ ] поиск циклов в графе;

- [ ] построение остовного дерева (любого).

### Вариант 6.3 (******) Неориентированный граф с петлями, мультидугами и весами на дугах

Дополнительные функции:

- [ ] поиск оптимальных путей из вершины в вершину – минимальных по стоимости – придумать класс + текстовое представление пути;

- [ ] построение остовного дерева – минимального по стоимости;

- [ ] вершинная/реберная раскраска;

- [ ] поиск циклов в графе.
